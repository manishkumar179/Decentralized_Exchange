// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

contract MockToken {
    string public name;
    string public symbol;
    uint256 public totalSupply;
    
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    
    constructor(string memory _name, string memory _symbol) {
        name = _name;
        symbol = _symbol;
        totalSupply = 1000000 ether;
        balanceOf[msg.sender] = totalSupply;
    }
    
    function transfer(address to, uint256 amount) external returns (bool) {
        balanceOf[msg.sender] -= amount;
        balanceOf[to] += amount;
        return true;
    }
    
    function transferFrom(address from, address to, uint256 amount) external returns (bool) {
        allowance[from][msg.sender] -= amount;
        balanceOf[from] -= amount;
        balanceOf[to] += amount;
        return true;
    }
    
    function approve(address spender, uint256 amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        return true;
    }
}

contract DecentralizedExchange {
    
    MockToken public tokenA;
    MockToken public tokenB;
    
    uint256 public reserveA;
    uint256 public reserveB;
    uint256 public totalLiquidity;
    
    mapping(address => uint256) public liquidity;
    
    address public owner;
    bool public initialized;
    
    constructor() {
        owner = msg.sender;
        autoSetup();
    }
    
    function autoSetup() internal {
        tokenA = new MockToken("DeFi Token", "DEFI");
        tokenB = new MockToken("Stable Coin", "STABLE");
        
        uint256 initialA = 10000 ether;
        uint256 initialB = 50000 ether;
        
        tokenA.approve(address(this), initialA);
        tokenB.approve(address(this), initialB);
        
        reserveA = initialA;
        reserveB = initialB;
        totalLiquidity = initialA * initialB / 1000;
        liquidity[owner] = totalLiquidity;
        
        tokenA.transfer(owner, 90000 ether);
        tokenB.transfer(owner, 450000 ether);
        
        initialized = true;
    }
    
    function addLiquidity() external returns (uint256 liquidityMinted) {
        uint256 amountA = 1000 ether;
        uint256 amountB = 5000 ether;
        
        tokenA.transferFrom(msg.sender, address(this), amountA);
        tokenB.transferFrom(msg.sender, address(this), amountB);
        
        liquidityMinted = (amountA * totalLiquidity) / reserveA;
        
        liquidity[msg.sender] += liquidityMinted;
        totalLiquidity += liquidityMinted;
        reserveA += amountA;
        reserveB += amountB;
    }
    
    function removeLiquidity() external returns (uint256 amountA, uint256 amountB) {
        uint256 liquidityAmount = liquidity[msg.sender] / 4; // Remove 25% of user's liquidity
        
        amountA = (liquidityAmount * reserveA) / totalLiquidity;
        amountB = (liquidityAmount * reserveB) / totalLiquidity;
        
        liquidity[msg.sender] -= liquidityAmount;
        totalLiquidity -= liquidityAmount;
        reserveA -= amountA;
        reserveB -= amountB;
        
        tokenA.transfer(msg.sender, amountA);
        tokenB.transfer(msg.sender, amountB);
    }
    
    function swapTokens(address tokenIn) external returns (uint256 amountOut) {
        uint256 amountIn = 100 ether; // Fixed swap amount
        
        MockToken(tokenIn).transferFrom(msg.sender, address(this), amountIn);
        
        if (tokenIn == address(tokenA)) {
            amountOut = (amountIn * reserveB) / (reserveA + amountIn);
            reserveA += amountIn;
            reserveB -= amountOut;
            tokenB.transfer(msg.sender, amountOut);
        } else {
            amountOut = (amountIn * reserveA) / (reserveB + amountIn);
            reserveB += amountIn;
            reserveA -= amountOut;
            tokenA.transfer(msg.sender, amountOut);
        }
    }
    
    function getInfo() external view returns (
        string memory nameA, 
        string memory nameB, 
        address addrA, 
        address addrB,
        uint256 resA,
        uint256 resB,
        bool ready
    ) {
        return (
            tokenA.name(), 
            tokenB.name(), 
            address(tokenA), 
            address(tokenB),
            reserveA,
            reserveB,
            initialized
        );
    }
}
